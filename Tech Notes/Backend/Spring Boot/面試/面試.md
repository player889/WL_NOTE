```ad-question
title: Spring Boot 的配置文件有哪幾種格式？它們有什麽區別？
.properties 和 .yml，它們的區別主要是書寫格式不同。
.yml 格式不支持 @PropertySource 註解導入配置。
```

```ad-question
title: Spring Boot 的核心註解是哪個？它主要由哪幾個註解組成的？

啟動類上面的註解是@SpringBootApplication，它也是 Spring Boot 的核心註解，主要組合包含了以下 3 個註解：
@SpringBootConfiguration：組合了 @Configuration 註解，實現配置文件的功能。
@EnableAutoConfiguration：打開自動配置的功能，也可以關閉某個自動配置的選項，如關閉數據源自動配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。
```

```ad-question
title: Spring Boot 需要獨立的容器運行嗎？
置了 Tomcat/ Jetty 等容器
```

```ad-question
title: 運行 Spring Boot 有哪幾種方式？
1. 打包用命令或者放到容器中運行
2. 用 Maven/ Gradle 插件運行
3. 直接執行 main 方法運行
```

```ad-question
title:如何在 Spring Boot 啟動的時候運行一些特定的代碼？
可以實現接口 ApplicationRunner 或者 CommandLineRunner，這兩個接口實現方式一樣，它們都只提供了一個 run 方法，
```

```ad-question
title: Spring Boot 有哪幾種讀取配置的方式？
Spring Boot 可以通過 @PropertySource,@Value,@Environment, @ConfigurationProperties 來綁定變量
```

```ad-question
title:Spring Boot 支持哪些日誌框架？推薦和默認的日誌框架是哪個？
Spring Boot 支持 Java Util Logging, Log4j2, Lockback 作為日誌框架，如果妳使用 Starters 啟動器，Spring Boot 將使用 Logback 作為默認日誌框架
```

```ad-question
title:Spring Boot 可以兼容老 Spring 項目嗎，如何做？
可以兼容，使用 @ImportResource
```

```ad-question
title: Spring Boot Actuator/執行器是什麽？
Spring Boot 提供執行器來監視和管理我們的應用程序。Actuator 是一個具有 HTTP 端點的工具。當應用程序被推送到生產環境時，可以選擇使用 HTTP 端點來管理和監控應用程序
```

```ad-question
title: spring-boot-starter-parent 主要有如下作用
1.  定義了 Java 編譯版本為 1.8 。
2. 使用 UTF-8 格式編碼。
3. 繼承自 spring-boot-dependencies，這個裏邊定義了依賴的版本，也正是因為繼承了這個依賴，所以我們在寫依賴時才不需要寫版本號。
4. 執行打包操作的配置。
5. 自動化的資源過濾。
6. 自動化的插件配置。
7. 針對 application.properties 和 application.yml 的資源過濾，包括通過 profile 定義的不同環境的配置文件，例如 application-dev.properties 和 application-dev.yml。
——————————
```

```ad-question
title: shiro和oauth還有cas他們之間的關系是什麼？問下您公司權限是如何設計，還有就是這幾個概念的區別。
cas和oauth是一個解決單點登錄的組件，shiro主要是負責權限安全方面的工作，所以功能點不一致。但往往需要單點登陸和權限控制一起來使用，所以就有 cas+shiro或者oauth+shiro這樣的組合。

token一般是客戶端登錄後服務端生成的令牌，每次訪問服務端會進行校驗，一般保存到內存即可，也可以放到其他介質；Redis可以做Session共享，如果前端web服務器有幾臺負載，但是需要保持用戶登錄的狀態，這場景使用比較常見。

我們公司使用oauth+shiro這樣的方式來做後臺權限的管理，oauth負責多後臺統一登錄認證，shiro負責給登錄用戶賦予不同的訪問權限。

[Ref.](https://www.cnblogs.com/hellxz/p/15768700.html)
```

```ad-question
title:SpringBoot自動配置的原理是什麽？
SpringBoot啟動的時候通過@EnableAutoConfiguration註解找到META-INF/spring.factories配置文件中所有的自動配置類，並對其進行加載，而這些自動配置類的類名都是以AutoConfiguration結尾來命名的，它實際上就是一個javaConfig形式的Spring容器配置類，它們都有一個@EnableConfigurationPerperties的註解，通過這個註解啟動XXXProperties命名的類去加載全局配置中的屬性，如server.port,而XXXProperties通過@ConfigurationProperties註解將全局配置文件中的屬性與自己的屬性進行綁定。 [Ref.](https://xie.infoq.cn/article/9e870a9d186f4a5d038d9ed3a)
```

```ad-question
title: Spring Boot 的自動配置是如何實現的？
Spring Boot 項目的啟動註解是：@SpringBootApplication，其實它就是由下面三個註解組成的：
- @Configuration
- @ComponentScan
- @EnableAutoConfiguration
  
其中 @EnableAutoConfiguration 是實現自動配置的入口，該註解又通過 @Import 註解導入了AutoConfigurationImportSelector，在該類中加載 META-INF/spring.factories 的配置信息。然後篩選出以 EnableAutoConfiguration 為 key 的數據，加載到 IOC 容器中，實現自動配置功能！

```

```ad-question
title:SpringBoot 配置加載順序?
1. properties文件
2.  YAML文件
3. 系統環境變量
4. 命令行參數
```

```ad-question
title:spring boot初始化環境變量流程?
1. prepareEnvironment方法去設置環境變量
2. getOrCreateEnvironment去初始化系統環境變量
3. configureEnvironment去初始化命令行參數
4. environmentPrepared當廣播到來的時候調用onApplicationEnvironmentPreparedEvent方法去使用postProcessEnvironment方法load yml和properties變量
```

```ad-question
title:SpringBoot 中如何解決跨域問題 ?
通過實現WebMvcConfigurer接口然後重寫addCorsMappings方法解決跨域問題。
```

```ad-question
title:什麽是 Swagger？妳用 SpringBoot 實現了它嗎？
Swagger 廣泛用於可視化 API，使用 Swagger UI 為前端開發人員提供在線沙箱。Swagger 是用於生成 RESTful Web 服務的可視化表示的工具，規範和完整框架實現。它使文檔能夠以與服務器相同的速度更新。當通過 Swagger 正確定義時，消費者可以使用最少量的實現邏輯來理解遠程服務並與其進行交互。因此，Swagger消除了調用服務時的猜測。
```

```ad-question
title: SpringBoot Starter 的工作原理是什麽？
SpringBoot 在啟動的時候會幹這幾件事情：
1. SpringBoot 在啟動時會去依賴的 Starter 包中尋找 resources/META-INF/spring.factories 文件，然後根據文件中配置的 Jar 包去掃描項目所依賴的 Jar 包。
2. 根據 spring.factories 配置加載 AutoConfigure 類
3. 根據 @Conditional 註解的條件，進行自動配置並將 Bean 註入 Spring Context

總結一下，其實就是 SpringBoot 在啟動的時候，按照約定去讀取 SpringBoot Starter 的配置信息，再根據配置信息對資源進行初始化，並註入到 Spring 容器中。這樣 SpringBoot 啟動完畢後，就已經準備好了一切資源，使用過程中直接註入對應 Bean 資源即可。
```

```ad-question
title: 談談自己對於Spring IOC和AOP的理解

==IOC==

- IOC（Inversion Of Controll，控制反轉）是一種設計思想，就是將原本在程序中手動創建對象的控制權，交由給Spring框架來管理。IOC在其他語言中也有應用，並非Spring特有。IOC容器是Spring用來實現IOC的載體，IOC容器實際上就是一個Map(key, value)，Map中存放的是各種對象。
將對象之間的相互依賴關系交給IOC容器來管理，並由IOC容器完成對象的註入。這樣可以很大程度上簡化應用的開發，把應用從復雜的依賴關系中解放出來。IOC容器就像是一個工廠一樣，當我們需要創建一個對象的時候，只需要配置好配置文件/註解即可，完全不用考慮對象是如何被創建出來的。在實際項目中一個Service類可能由幾百甚至上千個類作為它的底層，假如我們需要實例化這個Service，可能要每次都搞清楚這個Service所有底層類的構造函數，這可能會把人逼瘋。如果利用IOC的話，妳只需要配置好，然後在需要的地方引用就行了，大大增加了項目的可維護性且降低了開發難度。
Spring時代我們一般通過XML文件來配置Bean，後來開發人員覺得用XML文件來配置不太好，於是Sprng Boot註解配置就慢慢開始流行起來。
- Spring IOC 負責創建對象，管理對象（通過依賴註入（DI），裝配對象，配置對象，並且管理這些對象的整個生命周期。
- IOC 或 依賴註入把應用的代碼量降到最低。它使應用容易測試，單元測試不再需要單例和JNDI查找機制。最小的代價和最小的侵入性使松散耦合得以實現。IOC容器支持加載服務時的餓漢式初始化和懶加載。

==AOP==

AOP（Aspect-Oriented Programming，面向切面編程）能夠將那些與業務無關，卻為業務模塊所共同調用的邏輯或責任（例如事務處理、日誌管理、權限控制等）封裝起來，便於減少系統的重復代碼，降低模塊間的耦合度，並有利於未來的可擴展性和可維護性。
Spring AOP是基於動態代理的，如果要代理的對象實現了某個接口，那麽Spring AOP就會使用JDK動態代理去創建代理對象；而對於沒有實現接口的對象，就無法使用JDK動態代理，轉而使用CGlib動態代理生成一個被代理對象的子類來作為代理。
當然也可以使用AspectJ，Spring AOP中已經集成了AspectJ，AspectJ應該算得上是Java生態系統中最完整的AOP框架了。使用AOP之後我們可以把一些通用功能抽象出來，在需要用到的地方直接使用即可，這樣可以大大簡化代碼量。我們需要增加新功能也方便，提高了系統的擴展性。日誌功能、事務管理和權限管理等場景都用到了AOP。

Spring切面可以應用五種類型的通知：

1. before：前置通知，在一個方法執行前被調用
2. after：在方法執行之後調用的通知，無論方法執行是否成功
3. after-returning：僅當方法成功完成後執行的通知
4. after-throwing：在方法拋出異常退出時執行的通知
5. 5.around：在方法執行之前和之後調用的通知

切點 - 切入點是一個或一組連接點，通知將在這些位置執行。可以通過表達式或匹配的方式指明切入點。
```

```ad-question
title: 什麽是Spring的依賴註入？
依賴註入，是IOC的一個方面，是個通常的概念，它有多種解釋。這概念是說妳不用創建對象，而只需要描述它如何被創建。妳不在代碼裏直接組裝妳的組件和服務，但是要在配置文件裏描述哪些組件需要哪些服務，之後一個容器（IOC容器）負責把它們組裝起來。
```

```ad-question
title: 有哪些不同類型的IOC（依賴註入）方式？
- 構造器依賴註入：構造器依賴註入通過容器觸發一個類的構造器來實現的，該類有一系列參數，每個參數代表一個對其他類的依賴。
- Setter方法註入：Setter方法註入是容器通過調用無參構造器或無參static工廠 方法實例化bean之後，調用該bean的setter方法，即實現了基於setter的依賴註入。
```

```ad-question
title: Spring中的bean的作用域有哪些？
1. singleton：唯一bean實例，Spring中的bean默認都是單例的。
2. prototype：每次請求都會創建一個新的bean實例。
3. request：每一次HTTP請求都會產生一個新的bean，該bean僅在當前HTTP request內有效。
4. session：每一次HTTP請求都會產生一個新的bean，該bean僅在當前HTTP session內有效。
5. global-session：全局session作用域，僅僅在基於Portlet的Web應用中才有意義，Spring5中已經沒有了。Portlet是能夠生成語義代碼（例如HTML）片段的小型Java Web插件。它們基於Portlet容器，可以像Servlet一樣處理HTTP請求。但是與Servlet不同，每個Portlet都有不同的會話。
```

```ad-question
title: Spring中的bean生命周期？
1. Bean容器找到配置文件中Spring Bean的定義。
2. Bean容器利用Java Reflection API創建一個Bean的實例。
3. 如果涉及到一些屬性值，利用set()方法設置一些屬性值。
4. 如果Bean實現了BeanNameAware接口，調用setBeanName()方法，傳入Bean的名字。
5. 如果Bean實現了BeanClassLoaderAware接口，調用setBeanClassLoader()方法，傳入ClassLoader對象的實例。
6. 如果Bean實現了BeanFactoryAware接口，調用setBeanClassFacotory()方法，傳入ClassLoader對象的實例。
7. 與上面的類似，如果實現了其他*Aware接口，就調用相應的方法。
8. 如果有和加載這個Bean的Spring容器相關的BeanPostProcessor對象，執行postProcessBeforeInitialization()方法。
9. 如果Bean實現了InitializingBean接口，執行afeterPropertiesSet()方法。
10. 如果Bean在配置文件中的定義包含init-method屬性，執行指定的方法。
11. 如果有和加載這個Bean的Spring容器相關的BeanPostProcess對象，執行postProcessAfterInitialization()方法。
12. 當要銷毀Bean的時候，如果Bean實現了DisposableBean接口，執行destroy()方法。
13. 當要銷毀Bean的時候，如果Bean在配置文件中的定義包含destroy-method屬性，執行指定的方法。
![[Pasted image 20230208142722.png]]
```

```ad-question
title: Spring MVC的工作原理了解嘛？
流程說明：
1. 客戶端（瀏覽器）發送請求，直接請求到DispatcherServlet。
2. DispatcherServlet根據請求信息調用HandlerMapping，解析請求對應的Handler。(Spring的MVC框架是圍繞DispatcherServlet來設計的，它用來處理所有的HTTP請求和響應。)
4. 解析到對應的Handler（也就是我們平常說的Controller控制器）。
5. HandlerAdapter會根據Handler來調用真正的處理器來處理請求和執行相對應的業務邏輯。
6. 處理器處理完業務後，會返回一個ModelAndView對象，Model是返回的數據對象，View是邏輯上的View。
7. ViewResolver會根據邏輯View去查找實際的View。
8. DispatcherServlet把返回的Model傳給View（視圖渲染）。
9. 把View返回給請求者（瀏覽器）
```

```ad-question
title: Spring框架中用到了哪些設計模式
1. 工廠設計模式：Spring使用工廠模式通過BeanFactory和ApplicationContext創建bean對象。
2. 代理設計模式：Spring AOP功能的實現。
3. 單例設計模式：Spring中的bean默認都是單例的。
4. 模板方法模式：Spring中的jdbcTemplate、hibernateTemplate等以Template結尾的對數據庫操作的類，它們就使用到了模板模式。
5. 包裝器設計模式：我們的項目需要連接多個數據庫，而且不同的客戶在每次訪問中根據需要會去訪問不同的數據庫。這種模式讓我們可以根據客戶的需求能夠動態切換不同的數據源。
6. 觀察者模式：Spring事件驅動模型就是觀察者模式很經典的一個應用。
7. 適配器模式：Spring AOP的增強或通知（Advice）使用到了適配器模式、Spring MVC中也是用到了適配器模式適配Controller。
```

```ad-question
title: @Component和@Bean的區別是什麽
1. 作用對象不同。@Component註解作用於類，而@Bean註解作用於方法。
2. @Component註解通常是通過類路徑掃描來自動偵測以及自動裝配到Spring容器中（我們可以使用@ComponentScan註解定義要掃描的路徑）。@Bean註解通常是在標有該註解的方法中定義產生這個bean，告訴Spring這是某個類的實例，當我需要用它的時候還給我。
3. @Bean註解比@Component註解的自定義性更強，而且很多地方只能通過@Bean註解來註冊bean。比如當引用第三方庫的類需要裝配到Spring容器的時候，就只能通過@Bean註解來實現。
```

```ad-question
title: 將一個類聲明為Spring的bean的註解有哪些？
我們一般使用@Autowired註解去自動裝配bean。而想要把一個類標識為可以用@Autowired註解自動裝配的bean，可以采用以下的註解實現：
1. @Component註解。通用的註解，可標註任意類為Spring組件。如果一個Bean不知道屬於哪一個層，可以使用@Component註解標註。  
2. @Repository註解。對應持久層，即Dao層，主要用於數據庫相關操作。
3. @Service註解。對應服務層，即Service層，主要涉及一些復雜的邏輯，需要用到Dao層（註入）。
4. @Controller註解。對應Spring MVC的控制層，即Controller層，主要用於接受用戶請求並調用Service層的方法返回數據給前端頁
```

```ad-question
title: Spring事務中有哪幾種事務傳播行為？
在TransactionDefinition接口中定義了七個表示事務傳播行為的常量。

支持當前事務的情況：

1. PROPAGATION_REQUIRED：如果當前存在事務，則加入該事務；如果當前沒有事務，則創建一個新的事務。
2. PROPAGATION_SUPPORTS： 如果當前存在事務，則加入該事務；如果當前沒有事務，則以非事務的方式繼續運行。
3. PROPAGATION_MANDATORY： 如果當前存在事務，則加入該事務；如果當前沒有事務，則拋出異常。（mandatory：強制性）。

不支持當前事務的情況：
1. PROPAGATION_REQUIRES_NEW： 創建一個新的事務，如果當前存在事務，則把當前事務掛起。
2. PROPAGATION_NOT_SUPPORTED： 以非事務方式運行，如果當前存在事務，則把當前事務掛起。
3. PROPAGATION_NEVER： 以非事務方式運行，如果當前存在事務，則拋出異常。

其他情況：
1. PROPAGATION_NESTED： 如果當前存在事務，則創建一個事務作為當前事務的嵌套事務來運行；如果當前沒有事務，則該取值等價於PROPAGATION_REQUIRED。

[Ref. 1](https://blog.51cto.com/u_15246373/4920953)

[Ref. 2](http://college.creditease.cn/detail/383)

[Ref. 3](https://blog.51cto.com/u_15499328/5159193)
```

```ad-question
title: 哪些是重要的bean生命周期方法？ 妳能重載它們嗎？

有兩個重要的bean 生命周期方法，第一個是setup ， 它是在容器加載bean的時候被調用。第二個方法是 teardown 它是在容器卸載類的時候被調用。
The bean 標簽有兩個重要的屬性（init-method和destroy-method）。用它們妳可以自己定制初始化和註銷方法。它們也有相應的註解（@PostConstruct和@PreDestroy）。
```

```ad-question
title: SpringBoot性能如何優化
- 如果項目比較大，類比較多，不使用@SpringBootApplication，采用@Compoment指定掃包範圍
- 在項目啟動時設置JVM初始內存和最大內存相同
- 將springboot內置服務器由tomcat設置為undertow
```

