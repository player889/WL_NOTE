由於Http連接是無狀態的，所以使用Tomcat做服務器的時候Tomcat內部會維護一個叫做Session的東東用來保存客戶端的狀態，一般情況下每個客戶端都有一個cookie裏面保存著叫jsessionid的cookie，每次訪問tomcat的時候都會攜帶上，Tomcat可以根據這個jsessionid找到對應的session。就像妳去超市買東西，門口的儲物櫃可以視作一個session容器，而打出的二維碼條就是cookie。
在分布式系統中，對於同一個客戶端，訪問哪個Tomcat服務器就會在哪個Tomcat裏面創建session。簡單來說我做一個登錄功能，即第一次訪問Tomcat的時候需要輸入用戶名密碼，訪問成功後就在自己的sesison裏面寫入用戶名，那麼我下次訪問的時候直接檢測session裏是否有自己的用戶名來判斷自己是否處於登錄狀態了。現在問題來了，如果我第一次訪問的是TomcatA，登錄成功後由於nginx的負載均衡第二次訪問打到了TomcatB上，那麼TomcatB裏面並沒有我的用戶名信息，所以我還需要重新登錄。一個最直觀的想法就是把TomcatA和TomcatB的session抽出來放到某一個位置，這樣不管訪問TomcatA還是TomcatB都會從同一個Session裏面獲取用戶信息。
SpringBoot以一個非常簡潔易用的方式幫我們實現了分布式Session，我們需要做的僅僅是1個註解，幾行配置，幾行代碼。

HttpSession是由servelet容器進行管理的。而我們常用的應用容器有 Tomcat/Jetty等， 這些容器的HttpSession都是存放在對應的應用容器的內存中，在分布式集群的環境下，通常我們使用Nginx或者LVS、Zuul等進行反向代理和負載均衡，因此用戶請求是由一組提供相同服務的應用來進行處理，而用戶最終請求到的服務由Nginx和LVS、Zuul進行確定。


例如:我們現在有2相同的服務,服務A和服務B，通過Nginx進行反向代理和負載均衡，用戶請求，登錄時由服務A進行處理，而修改用戶資料有服務B進行處理。當前HttpSession是存放在服務A的內存中，而進行修改資料的時候由服務


互聯網服務離不開用戶認證。一般流程是下面這樣。

1、用戶向服務器發送用戶名和密碼。
2、服務器驗證通過後，在當前對話（session）裏面保存相關數據，比如用戶角色、登錄時間等等。
3、服務器向用戶返回一個 session_id，寫入用戶的 Cookie。
4、用戶隨後的每一次請求，都會通過 Cookie，將 session_id 傳回服務器。
5、服務器收到 session_id，找到前期保存的數據，由此得知用戶的身份。
這種模式的問題在於，擴展性（scaling）不好。單機當然沒有問題，如果是服務器集群，或者是跨域的服務導向架構，就要求 session 數據共享，每臺服務器都能夠讀取 session。

舉例來說，A 網站和 B 網站是同一家公司的關聯服務。現在要求，用戶只要在其中一個網站登錄，再訪問另一個網站就會自動登錄，請問怎麽實現？

一種解決方案是 session 數據持久化，寫入數據庫或別的持久層。各種服務收到請求後，都向持久層請求數據。這種方案的優點是架構清晰，缺點是工程量比較大。另外，持久層萬一掛了，就會單點失敗。

另一種方案是服務器索性不保存 session 數據了，所有數據都保存在客戶端，每次請求都發回服務器。JWT 就是這種方案的一個代表。